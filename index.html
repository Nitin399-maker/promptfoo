<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Promptfoo WebContainer Runner</title>
</head>
<body>
    <h1>Promptfoo Configuration Runner</h1>
    
    <input type="file" id="configFile" accept=".yaml,.yml" />
    <br /><br />
    
    <button id="runEval" disabled>Run Promptfoo Evaluation</button>
    <button id="clearOutput">Clear</button>
    <br /><br />
    
    <div id="logs" style="border:1px solid #ccc; margin-top:10px; padding:10px; height:200px; overflow-y:auto; background:#f5f5f5; font-family:monospace; font-size:12px;"></div>
    
    <div id="output" style="border:1px solid #ccc; margin-top:10px; padding:10px; height:400px; overflow-y:auto; white-space:pre-wrap; font-family:monospace;"></div>
    <script type="module">
        import { WebContainer } from "https://cdn.jsdelivr.net/npm/@webcontainer/api@1.5.3/+esm";
        
        let webcontainerInstance;
        let configContent = null;
        const configFile = document.getElementById('configFile');
        const runButton = document.getElementById('runEval');
        const clearButton = document.getElementById('clearOutput');
        const logsDiv = document.getElementById('logs');
        const outputDiv = document.getElementById('output');
        
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logsDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }
        
        // Handle file upload
        configFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                configContent = await file.text();
                runButton.disabled = false;
                log(`üìÅ Config file loaded: ${file.name}`);
            }
        });
        
        // Boot WebContainer and install promptfoo
        async function initWebContainer() {
            log('üöÄ Booting WebContainer...');
            const wc = await WebContainer.boot();
            log('‚úÖ WebContainer booted');
            
            // Create multiple telemetry disable methods
            log('üì¶ Disabling telemetry (multiple methods)...');
            
            // Method 1: Environment variables
            await wc.fs.writeFile('.env', `NO_TELEMETRY=1
                    PROMPTFOO_DISABLE_TELEMETRY=1
                    PROMPTFOO_NO_TELEMETRY=true
                    DO_NOT_TRACK=1
                    CI=true
                    `);
            log('‚úÖ Created .env file');
            
            // Method 2: Create promptfoo config to disable telemetry
            try {
                await wc.fs.mkdir('.promptfoo', { recursive: true });
                await wc.fs.writeFile('.promptfoo/config.json', JSON.stringify({
                    telemetry: false,
                    disableTelemetry: true
                }, null, 2));
                log('‚úÖ Created promptfoo config');
            } catch (e) {
                log(`‚ö†Ô∏è Could not create promptfoo config: ${e.message}`);
            }
            
            log('üìù Creating package.json...');
            await wc.fs.writeFile('package.json', JSON.stringify({
                name: 'promptfoo-runner',
                version: '1.0.0',
                private: true,
                dependencies: {
                    'promptfoo': '^0.67.0'
                }
            }, null, 2));
            log('‚úÖ package.json created');
            
            log('üì¶ Installing promptfoo...');
            const installProcess = await wc.spawn('npm', ['install'], {
                env: {
                    NO_TELEMETRY: '1',
                    PROMPTFOO_DISABLE_TELEMETRY: '1',
                    DO_NOT_TRACK: '1',
                    CI: 'true'
                }
            });
            
            let installCompleted = false;
            
            // Better output handling for npm install
            const handleInstallOutput = async () => {
                if (!installProcess.output) return;
                
                const reader = installProcess.output.getReader();
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            log('üì¶ npm install output stream ended');
                            break;
                        }
                        
                        // Handle both string and Uint8Array
                        let text = '';
                        if (typeof value === 'string') {
                            text = value;
                        } else if (value instanceof Uint8Array) {
                            text = new TextDecoder().decode(value);
                        }
                        
                        if (text) {
                            const lines = text.split('\n').filter(line => line.trim());
                            lines.forEach(line => {
                                if (line.trim()) {
                                    log(`npm: ${line.trim()}`);
                                }
                            });
                        }
                    }
                } catch (e) {
                    log(`‚ö†Ô∏è Install stream error: ${e.message}`);
                } finally {
                    try {
                        reader.releaseLock();
                    } catch (e) {
                        // Reader already released
                    }
                }
            };
            
            // Wait for both output processing and process exit
            const [exitCode] = await Promise.all([
                installProcess.exit,
                handleInstallOutput().catch(e => log(`Output handling error: ${e.message}`))
            ]);
            
            log(`üì¶ npm install process exited with code: ${exitCode}`);
            
            if (exitCode !== 0) {
                throw new Error(`npm install failed with exit code ${exitCode}`);
            }
            
            log('‚úÖ promptfoo installed successfully');
            
            // Verify installation
            try {
                const verifyProcess = await wc.spawn('npx', ['promptfoo', '--version']);
                const verifyExitCode = await verifyProcess.exit;
                log(`üîç Promptfoo version check exit code: ${verifyExitCode}`);
            } catch (e) {
                log(`‚ö†Ô∏è Could not verify promptfoo installation: ${e.message}`);
            }
            
            return wc;
        }

        // Run promptfoo evaluation
        async function runPromptfooEvaluation(wc, configContent) {
            log('üìù Writing config file...');
            await wc.fs.writeFile('promptfooconfig.yaml', configContent);
            log('‚úÖ Config file written');
            
            log('‚ö° Running promptfoo eval...');
            
            // Run with comprehensive telemetry disabling
            const evalProcess = await wc.spawn('npx', ['promptfoo', 'eval'], {
                env: {
                    NO_TELEMETRY: '1',
                    PROMPTFOO_DISABLE_TELEMETRY: '1',
                    PROMPTFOO_NO_TELEMETRY: 'true',
                    DO_NOT_TRACK: '1',
                    CI: 'true',
                    NODE_ENV: 'production'
                }
            });
            
            let output = '';
            let evalCompleted = false;
            
            // Monitor evaluation output with timeout
            const handleEvalOutput = async () => {
                if (!evalProcess.output) return;
                
                const reader = evalProcess.output.getReader();
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            log('‚ö° eval output stream ended');
                            break;
                        }
                        
                        let text = '';
                        if (typeof value === 'string') {
                            text = value;
                        } else if (value instanceof Uint8Array) {
                            text = new TextDecoder().decode(value);
                        }
                        
                        if (text) {
                            output += text;
                            
                            // Log real-time output
                            const lines = text.split('\n').filter(line => line.trim());
                            lines.forEach(line => {
                                if (line.trim()) {
                                    log(`eval: ${line.trim()}`);
                                }
                            });
                        }
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Output stream error: ${error.message}`);
                } finally {
                    try {
                        reader.releaseLock();
                    } catch (e) {
                        // Reader already released
                    }
                }
            };
            
            // Add timeout to prevent hanging
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => {
                    log('‚è∞ Adding 30 second timeout for eval process...');
                    resolve('timeout');
                }, 30000);
            });
            
            try {
                const result = await Promise.race([
                    Promise.all([
                        evalProcess.exit,
                        handleEvalOutput().catch(e => log(`Eval output error: ${e.message}`))
                    ]),
                    timeoutPromise
                ]);
                
                if (result === 'timeout') {
                    log('‚ö†Ô∏è Evaluation timed out after 30 seconds');
                    // Try to kill the process
                    try {
                        evalProcess.kill();
                    } catch (e) {
                        log(`‚ö†Ô∏è Could not kill process: ${e.message}`);
                    }
                } else {
                    const [exitCode] = result;
                    log(`üìä Evaluation finished (exit code: ${exitCode})`);
                }
            } catch (error) {
                log(`‚ùå Evaluation error: ${error.message}`);
            }
            
            // Try to read output files
            let fileOutputs = '';
            try {
                const files = await wc.fs.readdir('.');
                log(`üìÇ Files found: ${files.join(', ')}`);
                
                const outputFiles = files.filter(f => 
                    f.includes('output') || 
                    f.includes('result') || 
                    f.includes('eval') ||
                    f.startsWith('promptfoo') ||
                    (f.endsWith('.json') && !f.includes('package') && !f.includes('lock')) ||
                    (f.endsWith('.csv')) ||
                    (f.endsWith('.html'))
                );
                
                log(`üìÑ Potential output files: ${outputFiles.join(', ')}`);
                
                for (const file of outputFiles) {
                    try {
                        const stats = await wc.fs.stat(file);
                        if (stats.isFile()) {
                            const content = await wc.fs.readFile(file, { encoding: 'utf-8' });
                            fileOutputs += `\n\n=== ${file} ===\n${content}`;
                            log(`üìÑ Read output file: ${file}`);
                        }
                    } catch (e) {
                        log(`‚ö†Ô∏è Could not read: ${file} - ${e.message}`);
                    }
                }
                
                // Check for .promptfoo directory
                try {
                    const stats = await wc.fs.stat('.promptfoo');
                    if (stats.isDirectory()) {
                        const promptfooFiles = await wc.fs.readdir('.promptfoo');
                        log(`üìÇ .promptfoo files: ${promptfooFiles.join(', ')}`);
                        
                        for (const file of promptfooFiles) {
                            if (file.endsWith('.json') || file.endsWith('.html') || file.endsWith('.csv')) {
                                try {
                                    const filePath = `.promptfoo/${file}`;
                                    const fileStats = await wc.fs.stat(filePath);
                                    if (fileStats.isFile()) {
                                        const content = await wc.fs.readFile(filePath, { encoding: 'utf-8' });
                                        fileOutputs += `\n\n=== .promptfoo/${file} ===\n${content}`;
                                        log(`üìÑ Read promptfoo file: ${file}`);
                                    }
                                } catch (e) {
                                    log(`‚ö†Ô∏è Could not read .promptfoo/${file}: ${e.message}`);
                                }
                            }
                        }
                    }
                } catch (e) {
                    log('‚ö†Ô∏è No .promptfoo directory found');
                }
                
            } catch (e) {
                log(`‚ö†Ô∏è Could not scan for output files: ${e.message}`);
            }
            
            return `PROMPTFOO EVALUATION RESULTS
====================================
Timestamp: ${new Date().toISOString()}

Console Output:
${output || 'No console output captured'}

Generated Files:${fileOutputs || '\nNo output files found'}
====================================`;
        }
        
        // Run evaluation button
        runButton.addEventListener('click', async () => {
            if (!configContent) {
                log('‚ùå No config file loaded');
                return;
            }
            
            try {
                runButton.disabled = true;
                runButton.textContent = 'Running...';
                outputDiv.textContent = 'Initializing...';
                
                if (!webcontainerInstance) {
                    log('üîÑ Initializing WebContainer...');
                    webcontainerInstance = await initWebContainer();
                    log('‚úÖ WebContainer initialization completed');
                }
                
                log('üöÄ Starting evaluation...');
                const result = await runPromptfooEvaluation(webcontainerInstance, configContent);
                outputDiv.textContent = result;
                log('üéâ Evaluation process completed!');
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                outputDiv.textContent = `Error: ${error.message}\n\nStack trace:\n${error.stack}\n\nCheck logs for details.`;
                console.error('Full error:', error);
                
            } finally {
                runButton.disabled = false;
                runButton.textContent = 'Run Promptfoo Evaluation';
            }
        });
        
        // Clear output
        clearButton.addEventListener('click', () => {
            logsDiv.innerHTML = '';
            outputDiv.textContent = '';
            log('üßπ Output cleared');
        });
        
        // Check if WebContainer is available
        if (!crossOriginIsolated) {
            log('‚ùå WebContainer requires Cross-Origin Isolation headers');
            log('Deploy to Netlify/Vercel or serve with proper headers');
        } else {
            log('‚úÖ WebContainer environment ready');
        }
    </script>
</body>
</html>